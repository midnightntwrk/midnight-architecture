#+TITLE: Abcird

Abcird (pronounced /absurd/) is a proposed programming language for compiling
programs down to zkSNARKs.

Currently, abcird is aiming to support Plonk, therefore we might use the
following terms interchangeably:
- underlying proving systems, of which the current state of the art are
- SNARKs, which in the context of zero-knowledge are referred to as
- zkSNARKs, of which the current state of the art are
- Plonk instances, which are often abbreviated as
- Plonk, when referring to the chosen Plonk instance.

zkSNARKs, including Plonk, model the computation that we want to prove using
zero-knowledge as
- arithmetic circuits, which sometimes are sometimes referred to as
- zero-knowledge circuits, and altogether abbreviated as
- circuits.

We assume the basic knowledge of how zero-knowledge, including undestanding the
roles of prover and verifier. We write /witness/ or /witness vector/ to denote
the private inputs to the zero-knowledge proof and we write /statement/ or
/statement vector/ to denote the public inputs to the zero-knowledge proof. We
write /input/ or /input vector/ for the input to either prover or verifier,
meaning /witness/ together with /statement/ for the prover and /statement/ for
the verifier. Since the word "statement" often has a particular meaning in the
context of programming languages we prefer to refer to it as /input/ when
discussing verifier.

We do not assume any prior knowledge about circuits, but we do point out that in
our settings their are finite and bound by a constant.

We do not assume any prior knowledge about Plonk instances, but we do point out
that two Plonk instances are not compatible and can be treated as two separate
zkSNARKs.

The long-term goals of Abcird are to:
- provide a high-level programming language :: for writing programs which
  results need to be proven in zero-knowledge ([[* Abcird Programming Language]]).
  In the near term such programming language will be used by the Lares project
  for writing private smart contracts, however it could also be used by a larger
  Plonk community or retrofitted to a different underlying proving system.
- ease the transition between underlying proving systems :: when changing
  between incompatible underlying proving systems ([[* Transition Between Proving
  Systems]]). In the near term that means a transition between two Plonk
  instances, however it could also mean transitioning to a completely different
  zkSNARK or transitioning to a completely different scheme of proving systems.

* Abcird Programming Language

A compilation of an abcird program will involve the following tools:
- abcirdc :: a compiler written in Chez Scheme that compiles programs written in
  abcird programming language down to abcird bytecode, and
- abcird-vm :: a vm/runtime written in Rust that
  - compiles abcird bytecode to a compiled form that is understood by the
    underlying proving system, and
  - interpretes abcird bytecode to generate input vectors for the underlying
    proving system.

When working with abcird there will be following artifacts:

- abcird programs :: high-level programs written in abcird programming language,
- abcird bytecode :: abcird programs compiled by the abcird compiler,
- compiled circuits :: abcird bytecode compiled down to the form understood by
  the underlying proof system,
- input vectors :: computed input to the prover system.

** Compilation of Abcird programs
Compiling programs down to zkSNARKs usually poses an interesting challenge: not
only we need to generate a circuit for the c

** Compilation Artifacts vs Evaluation Artifacts

* Transition Between Proving Systems

The compilation pipeline for Abcird has the following elements
- an abcird program :: which is compiled by the abcird compiler to
- an abcird bytecode :: which is then interpreted by abcird vm to generate
  - compiled circuits :: in the form of
    - prover key :: and
    - verifier key :: .

then, during execution the abcird bytecode is interpreted by abcird vm to
produce
 - input vectors ::
   - witness vector :: and
   - statement vector :: .

In order to prove the abcird vm takes
- prover key,
- witness vector, and
- statement vector
in order to produce a proof.

In order to verify the abcird vm takes
- proof,
- verifier key, and
- statement vector
in order to verify the proof.

Therefore there are these distinct steps
- bytecode compilation
- circuit compilation
- input generation
- proof generation/verification

Therefore there are the following levels of compatibility
- source code compatible :: which is the weakest level of compatibility and does
  not provide any guarantees,
- bytecode compatible :: meaning that we do not need to recompile the bytecode,
- input compatible :: meaning that we do not need to regenerate the input,
- circuit compatible :: meaning that we do not need to recompile the circuit,
- proof compatible :: meaning that we do not need to regenerate the proof.

** Input Compatibility vs Circuit Compatibility
There is an interesting relation between input compatibility and circuit
compatibility.

Firstly, it is very easy to imagine that circuit compilation occurs before input
generation because circuit compilation feels like a part of a compilation
pipeline, whereas input generation is distinctly a runtime operation because we
need the inputs to the abcird program so we can generate the input to the prover
or verifier.

Still, input generation is independent to circuit compilation, and theoretically
leads to the following ordering
#+begin_src artist
                 +----------------------+
                 |source code compatible|
                 +----------------------+
                             |
                             |
                             |
                  +--------------------+
                  |byte code compatible|
                  +--------------------+
                            /\
               *-----------*  *-----------*
              /                            \
    +------------------+          +----------------+
    |circuit compatible|          |input compatible|
    +------------------+          +----------------+
              \                            /
               *-----------*  *-----------*
                            \/
                    +----------------+
                    |proof compatible|
                    +----------------+
#+end_src
meaning that some updates or modifications could be
- circuit compatible but not input compatible, or
- input compatible but not circuit compatible.

In practice, we so far encountered the latter (for example, when switching to a
plonk instance with an additional custom gate) and we are not sure if the former
is even possible, as input compatibility seems to be implied by the circuit
compatibility.
