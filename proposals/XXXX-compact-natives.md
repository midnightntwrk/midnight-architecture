# Proposal XXXX: Compact Native Bindings

The Compact standard library exposes cryptographic features that are implemented
by the underlying proof system found in the proof server.  Adding these features
is currently a heavyweight and labor intensive process.  It requires:

  - declarations of type signatures in the standard library, and for the
    compiler, and
  - an implementation in Rust (compiled to WASM) for the compiler's JavaScript
    runtime, and
  - new instructions added to the ZKIR intermediate langauge and the compiler's
    ZKIR backend, and
  - an implementation of the ZKIR instructions in the proof server.

There are some negative consequences of this design.  For instance:

  - the Midnight crypto team is concerned that the implementation of
    cryptographic primitives is not as efficient as it can be in the proof
    server (reflectively negatively on the Midngight network), and
  - some potential partners consider some missing features to be "deal breakers"
    for working with Midnight, and
  - at least one potential partner is bypassing Compact to generate ZKIR and
    Impact VM code by hand.  This must be a tedious and error prone process.
  
We propose an ultimately more lightweight and less labor intensive process for
exposing cryptographic features implemente by the proof server.  Specifically,
we well use a domain specifi declarative **Interface Definition Language** (IDL)
to describe the binding between Compact's standard library and the proof server,
and we will implement a binding generator program that will generate most of the
boilerplate code necessary to expose the proof server features in Compact.

## Overview of the Current Implementation

Here we describe the current implementation is detail, before we present a way
to simplify it.

### Compilation of Native Functions

The Compact standard library is a builtin Compact module.  It's builtin in the
sense that the compiler knows about it and has special code to handle it.
Programmers who want to use it can import it into their programs by writing
`import CompactStandardLibrary`.

The implementation of the standard library module is found in the file Compact
source code file `compiler/standard-library.compact` in the `compactc`
compiler's GitHub repository.  This file has Compact source code implementations
of most of the types and circuits exported by the standard library module.

Some of the circuits, however, do not have Compact source code implementations.
Instead, they have only signatures in `compiler/standard-library.compact`.  As
examples, there are:

```
export circuit transient_hash<a>(value: a): Field;
export circuit transient_commit<a>(value: a, rand: Field): Field;
```

These are generic circuits, represented by the syntax `<a>` in their
declaration.  This means that they are parameterized over a Compact type `a`.
The compiler generates a specialization of these circuits for each type `a`
that they are used with in a Compact program.  The implementation of these
circuits is a special one, declared to the compiler in the Scheme source code
file `compiler/midnight-natives.ss`.  For instance, for these two circuits
there is:

```
(declare-native-entry external disclosing transient_hash [A]
  "__compactRuntime.transientHash"
  (A)
  Field)

(declare-native-entry external nondisclosing transient_commit [A]
  "__compactRuntime.transientCommit"
  (A Field)
  Field)
```

The compiler processes these and inserts them into a hash table, keyed by their
Compact name (respectively `transient_hash` and `transient_commit`).

The "class" of the native entry is either `external`, which both of these
are, or `witness` which has a custom TypeScript implementation.  An example of
`witness` natives are ones that are implemented by the wallet.  We will not
consider them further in this proposal.

The entries are marked as `disclosing` or `nondisclosing`.  This is metadata
that tells the compiler whether they are considered to leak witness return
values provided as their arguments.  In this case, `transient_hash` does leak
its argument value, and `transient_commit` does not leak either of its argument
values.

They are generic, both with type parameters `A` in this specification.

They have a JavaScript function that the compiler should call as the body of
their implementation.  For example, the generic specializations of the Compact
standard library's `transient_hash` circuit will call
`__compactRuntime.transientHash` (where the contract's generated JS code has
imported the compiler's JS runtime as `__compactRuntime`).

Then they have type annotations for their argument and return types.

*[Note that both of these could be easily generated by a declarative
specification of the Compact signature and the binding to a JS function name.
I'm not even sure if the declaration of the circuit in the standard library's
Compact source code is necessary, perhaps only for documentation generation.]*

**Conjecture:** We can generate both the Compact standard library signature and
the compiler's binding to a JS runtime signature from a declarative
specification of the function.  We can probably generate the documentation in
the same way.  The burden is on the implementer to provide a JS-callable
implementation.

### Implementation in the Compiler's JavaScript Runtime

The compiler generates JavaScript code that imports a JavaScript runtime
package.  This contains implementations of a number of functions used by the
generated JavaScript code.  It also contains an embedded version of the Rust
implementation of the on-chain runtime (compiled to WASM).

The JS runtime needs to include implementations of all of these native
functions.  When the contract is run off chain in a DApp (before sending it to
the proof server, and then sending a transaction to the chain), it needs a
JS-callable implementation of this native function.

The implementation of `transientHash` in the JS runtime is found as Rust code in
the `midnight-ledger-prototype` GitHub repository in
`onchain-runtime-wasm/src/primitive.rs`:

```
#[wasm_bindgen(js_name = "transientHash")]
// function transientHash(align: Alignment, val: Value): Value
// circuit transient_hash[a](val: a): Field
pub fn transient_hash(align: JsValue, val: JsValue) -> Result<JsValue, JsError> {
    let val = AlignedValue::new(from_value(val)?, from_value(align)?)
        .ok_or(JsError::new("invalid alignment supplied"))?;
    let repr = ValueReprAlignedValue(val).field_vec();
    Ok(to_value(&Value::from(
        transient_crypto::hash::transient_hash(&repr),
    ))?)
}
```

This is mostly boilerplate.  The single argument as been turned into a pair of
alignment and value arguments.  An `AlignedValue` is constructed from them with
some error handling, and this value undergoes some conversions before being
passed to `transient_crypto::hash::transient_hash` and the result is converted
and returned.

If we look at the implementation of `transientCommit`, it is similar:

```
#[wasm_bindgen(js_name = "transientCommit")]
// function transientCommit(align: Alignment, val: Value, opening: Value): Value
// circuit transient_commit[a](val: a, opening: Field): Field
pub fn transient_commit(
    align: JsValue,
    val: JsValue,
    opening: JsValue,
) -> Result<JsValue, JsError> {
    let val = AlignedValue::new(from_value(val)?, from_value(align)?)
        .ok_or(JsError::new("invalid alignment supplied"))?;
    let opening: Value = from_value(opening)?;
    Ok(to_value(&Value::from(
        transient_crypto::hash::transient_commit(
            &ValueReprAlignedValue(val),
            (&*opening).try_into()?,
        ),
    ))?)
}
```

Again, there is some conversion and checking of the arguments, a call to a Rust
function `transient_crypto::hash::transient_commit`, and then some checking and
conversion of the result.

We conjecture that:

  - the argument and result conversions are boilerplate and are type-directed,
    that is they can be generated based on their Compact types, and
  - the implementation can be expressed as a single Rust function with a
    predictable signature (based on the Compact signature).

Not all of these functions are necessarily currenly implemented as a single Rust
function, but we conjecture that they could be structured that way.

**Conjecture:** We can generate the JS-callable Rust implementation in the
standard library from a declarative specification.  This can be the same
specification we used to generate the Compact signature and the compiler's
binding to a JS function.  The burden is on the implementer to provide a Rust
implementation with a predictable signature.

### Implementation in the Compiler's ZKIR Backend

The Compact compiler generates two different outputs: a JS implementation of the
Compact code which is used off chain and before invoking the proof server, and
an intermediate representation that is used to invoke the proof server.  The
second of these is an intermediate representation we have designed called ZKIR.

The implementation of these in the compiler's ZKIR backend is similar to the
compiler's handling of the JS implementation, but a bit more ad hoc.  The JS
implementation was generated by a declarative specification in the form of
Scheme `declare-native-entry` declarations.  These were used to populate a hash
table with information about the JS implementations keyed by the Compact
standard library names of the circuits.

A similar thing happens for the ZKIR backend but it's implemented in algorithmic
Scheme code (instead of a declarative specification).  In
`compiler/zkir-passes.ss` in the compiler's GitHub repository, there is Scheme
source code to build a hash table of ZKIR circuit representations keyed by the
Compact standard library name of the circuit.

For `transient_hash`, it has:

```
(register-handler! 'transient_hash
  (lambda (align res* . xs)
    (print-gate "transient_hash" `[inputs ,xs])
    (new-var! (car res*) #f)))
```

and for `transient_commit`, it has:

```
(register-handler! 'transient_commit
  ;; First n-1 args are the object being committed.
  ;; Final arg is commitment nonce.
  ;; commit algorithm is: object.fold(nonce, poseidon_compress)
  (lambda (align res* . args*)
    (print-gate "transient_hash" `[inputs ,(cons (car (list-tail args* (sub1 (length args*))))
                                                 (list-head args* (sub1 (length args*))))])
    (new-var! (car res*) #f)))
```

Both of these are implemented by a single ZKIR `transient_hash` gate.  There is
some boilerplate related to input and result handling that we conjecture is
type-directed and could be generated from a declarative specification of the
Compact signature of the circuit.

These are Scheme procedures that are invoked with the right arguments because
the are invoked very late in the compiler pipeline, after all type checking is
performed.

**Conjecture:** there are two possible cases here: (1) it is a simplification of
the implementation that these two standard library functions use the same ZKIR
gate, and we could as well have distinct gates for them, or (2) it is essential
that these are the same gates and we need to parameterize any declarative
specification over the Scheme code to be used by the Compact compiler in its
ZKIR backend implementation.**

It still looks like this is boilerplate, where we either have to parameterize
these operations over compiler implementations for the ZKIR backend or else over
distinct ZKIR gates.

### Implementation in the Proof Server

*[Note: I'm not actually sure if this implementation is compiled into the proof
server, or if there is a binary that sits between the JS runtime and the proof
server.]*

The compiler generates ZKIR output for each (impure, exported) circuit.  This
includes embedded instructions for native standard library circuits like
`transient_hash` and `transient_commit`.  These are then interpreted and turned
into calls to the proof server's APIs.  For the `TransientHash` instruction,
this is implemented in the `midnight-ledger-prototype` GitHub repository in
`transient-crypto/src/proofs/ir_vm.rs`:

```
I::TransientHash { inputs } => mem_push(
    std.poseidon(
        layouter,
        &inputs
            .iter()
            .map(|inp| idx(&memory, *inp).cloned())
            .collect::<Result<Vec<_>, _>>()?,
    )?,
    &mut memory,
)?,
```

This has some wrapper code and calls `std.poseidon`.  Here we are farther from
the Compact source implementation.  We conjecture that we can either express all
of these implementations as single Rust functions, or that we can express them
as Rust source code.

## Proposal for Binding to Cryptographic Functions

Here we propose to generate all of this implementation from a single declarative
specification.  It includes:

  - the Compact signature of the standard library circuit, and

  - the circuit's documentation, and
  
  - the name of the JS runtime function implementing the circuit (assuming that
    the JS boilerplate to invoke the circuit is type-directed), and
    
  - the name of a Rust implementation for the JS runtime (assuming that the
    wrapping and unwrapping code is type-directed), and
    
  - either Scheme code to emit ZKIR for the circuit, or a single ZKIR gate name,
    and
    
  - a translation for the proof server in terms of calls to a Rust implemntation
    function, assuming that the boilerplate is again type-directed.
    
The burden on the implementer to provide a new Compact standard library function
exposing a native cryptographic feature could therefore be as little as:

  - describe the Compact sigature and documentation, and

  - provide a Rust implementation for the JS runtime, and
  
  - provide a ZKIR gate and an implementation in terms of the proof server.
  
## Proposal for Native Types

A request from the Midnight crypto team was for Compact to expose a more
efficient implementation of native elliptic curve operations.  The Compact
standard library exposes `ec_add`, `ec_mul`, `ec_mul_generator`, and
`hash_to_curve` circuits that operate on and/or return `CurvePoint`s.  These are
represented in Compact as a Compact `struct` declaration with a pair of `Field`
values:

```
export struct CurvePoint {
  x: Field;
  y: Field;
}
export circuit ec_add(a: CurvePoint, b: CurvePoint): CurvePoint;
export circuit ec_mul(a: CurvePoint, b: Field): CurvePoint;
export circuit ec_mul_generator(b: Field): CurvePoint;
export circuit hash_to_curve<a>(value: a): CurvePoint;
```

An observation from the Midnight crypto team was that there was a native
representation of curve points, which was more efficient than an implementation
in terms of a pair of `Field` values.

To support this, we will additionally need a notion of **native types** which
are understood by the underlying crypto system but assumed to be opaque to
Compact.  Instead of declaring a transparent Compact `struct` type, we need a
way to declare a type like this to be a native type and opaque to Compact.

In this case, the only way to create a legitimate `CurvePoint` is according to
the API above.  The [*hand-written?*] documentation of `CurvePoint` says "Only
outputs of elliptic curve operations are actually guaranteed to lie on the
curve.".

We instead need a way of representing these as "native" types.  Then we need a
declarative way of describing how to translate them to JS runtime types for the
required JS runtime implementation of these functions.

And we need a declarative way of specifying that they have custom
representations in the ZKIR intermediate representation.
