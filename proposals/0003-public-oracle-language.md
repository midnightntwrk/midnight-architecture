# Proposal 0003: A Language for Public Oracles
This proposal captures the goals for our public oracle language, shows some of
the available trade-offs, and recommends a selection from these. Notably, we are
constrained by considerations around gas fees, and support for future roll-ups
and off-chain channels.

# Problem Statement
What language should our public oracle queries be written in? We have a few
major considerations to bear in mind.

## Notation

* We assume a set $\mathcal{T}$ of possible transactions, and a subset $\mathcal{H} \subseteq \mathcal{T}$ of transactions that may be generated by honest users.
* We assume an initial ledger state $\sigma_0$, and an operation
$\mathsf{apply}$ describing an effect of any transaction $\tau \in \mathcal{T}$
in a state $\sigma$, $\sigma' \gets \mathsf{apply}(\tau, \sigma)$ (if $\sigma = \sigma'$, we say the transaction is *rejected*).
* We define $\mathsf{reachable}(\sigma) := \\{\sigma\\} \cup \bigcup \\{\\;\mathsf{reachable}(\mathsf{apply}(\tau, \sigma)) \mid \tau \in \mathcal{T}\\;\\}$.
* We assume a transaction $\tau \in \mathcal{T}$ induces a state precondition predicate $P_\tau$, and postcondition predicate $Q_\tau$. (We can see $\mathcal{T}$ and $\mathcal{H}$ as sets of triples $(\tau, P_\tau, Q_\tau)$, although we will write $\tau \in \mathcal{T}$ for convenience)
* We write $T(f, x_1, \ldots, x_n)$ for the execution time complexity of $f(x_1, \ldots, x_n)$.
* We write $x \xleftarrow{*} S$ to denote $x$ being a randomly sampled value from $S$. We write $\mathcal{H}(\sigma)$ for the random variable of anticipated user behaviour when they observe state $\sigma$.
* For simplicity, we assume that $\log(|\sigma|)$ is constant for all $\sigma \in \textsf{reachable}(\sigma_0)$.

## Desired properties of transactions

1. **Fairness.** Users should not pay for failed transactions.
   $\forall \tau \in \mathcal{H}, \sigma \in \mathsf{reachable}(\sigma_0) : \text{let }\sigma' \gets \mathsf{apply}(\tau, \sigma) \text{ in } \lnot P_\tau(\sigma) \implies \sigma = \sigma'$
2. **DoS Protection.** Transaction which cannot pay should be invalidated in $O(|\tau|)$.
   $\exists V : \forall \sigma \in \mathsf{reachable}(\sigma_0) : (\forall \tau \in \mathcal{H}(\cdot) : V(\tau, \sigma) \implies P_\tau(\sigma)) \land (\forall \tau \in \mathcal{T} : (P_\tau(\sigma) \implies V(\tau, \sigma)) \land V(\tau, \sigma) \in O(|\tau|))$
3. **Consistency.** A transaction satisfying its preconditions should satisfy its postconditions.
   $\forall \tau \in \mathcal{T}, \sigma \in \mathsf{reachable}(\sigma_0) . P_\tau(\sigma) \implies Q_\tau(\sigma, \mathsf{apply}(\tau, \sigma))$
4. **Compressability.** Composition should heuristically compress: We want a composition operator
   $\circ$, such that for transactions $\tau_1, \tau_2 \in \mathcal{T}; \sigma \in \mathsf{reachable}(\sigma_0)$ (and when we say "heuristically", with large probability for $\tau_1, \tau_2 \xleftarrow{*} \mathcal{H}(\sigma)$ ):
   * $\mathsf{apply}(\tau_1 \circ \tau_2, \sigma) \in \\{\sigma, \mathsf{apply}(\tau_2, \mathsf{apply}(\tau_1, \sigma))\\}$ (and heuristically, it is likely that if $\mathsf{apply}(\tau_2, \mathsf{apply}(\tau_1, \sigma))) \neq \sigma$ then $\mathsf{apply}(\tau_1 \circ \tau_2, \sigma) \neq \sigma$)
   * $|\tau_1 \circ \tau_2| \leq |\tau_1| + |\tau_2|$ (and heuristically, it is likely that $|\tau_1 \circ \tau_2| \ll |\tau_1| + |\tau_2|$ )
   * $T(\mathsf{apply}, \tau_1 \circ \tau_2, \sigma) \leq T(\mathsf{apply}, \tau_2, \mathsf{apply}(\tau_1, \sigma)) + T(\mathsf{apply}, \tau_1, \sigma)$ (and heuristically, it is likely that $T(\mathsf{apply}, \tau_1 \circ \tau_2, \sigma) \ll T(\mathsf{apply}, \tau_2, \mathsf{apply}(\tau_1, \sigma)) + T(\mathsf{apply}, \tau_1, \sigma)$ )
5. **Contention Resistance.** For $\sigma \in \mathsf{reachable}(\sigma_0),\tau_1, \tau_2 \xleftarrow{*} \mathcal{H}(\sigma)$, it is likely that:
$P_{\tau_1}(\sigma) \land P_{\tau_2}(\sigma) \implies P_{\tau_2}(\mathsf{apply}(\tau_1, \sigma))$

# Proposed Changes

Here's a discussion of our current options.

## "Ethereum-style" freely programmable

Ethereum's (and many similar system's) approach to smart contract begins by
letting transaction be (essentially) arbitrary functions $f$ over state. This
necessitates tracking the execution cost of $f$, and having a computational
bound (gas limit) placed on it ahead of time. Transactions therefore are
composed of two parts: Fee payment, and transaction execution.

### Fairness

Fee payment is first done independently of transaction execution. As the payment
of fees is itself a state modifications, this severely limits the shape $P_\tau$
may take if fairness should hold: If the fee payment succeeds in a state
$\sigma$, $P_\tau(\sigma)$ must hold. In effect, this limits $P_\tau$ to balance
tests and signature checks.

### DoS Protection

DoS protection is not a challenge here, due to the limitation of precondition predicates.

### Consistency

Consistency, combined with the weakness of expressible preconditions, limits
the expressiveness of potential postconditions—that is, we can say little about
the effect of transactions, because we know little about the state they will be
run against.

### Compressability

Compressability has been proven in a limited capacity, essentially relying
on contract memory being independent of each other. Multiple interactions of a
single contract can always be compressed into a single state replacement,
although this relies on the state itself being succinct. In practice, this has
been achieved in Ethereum roll-ups.

### Contention Resistance

Contention resistance is mostly achieved, again due to the limited
expressive power of Ethereum's preconditions.

### Conclusion

Ethereum satisfies a weakened form of all of the desired properties, largely at
the expense of constraining the pre- and post-condition predicates to a barely
usable state.

## eUTXO-style

Extended UTXO systems, such as Cardano's, begin at defining the shape of their
state $\sigma$ as a set of transaction outputs. Transactions may produce new
outputs, and may consume inputs. Each UTXO (unspent transaction output) sets
conditions that must be satisfied to use it as an input. These conditions are
arbitrarily programmable.

As UTXOs have space for an arbitrary data field, it is possible to compute any
function $f$ between UTXOs within a single transaction. The model is
Turing-complete.

### Fairness

Fee payment is a part of Cardano, however happens only *after* the presence of
all inputs consumed by a transaction $\tau$ is confined. After this, a "simple"
input provides fee-payment for the computation the scripts checking the
transaction validity and if any of these fail, this fee payment still goes
through.

As the validity of these scripts is entirely deterministic, honest users will
not produce transactions containing scripts which fail to validate. Therefore,
to satisfy fairness, it is sufficient to say that the "simple" input validating,
and the presence of all input UTXOs in a transaction $\tau$ in state $\sigma$
must imply $P_\tau(\sigma)$. As the presence of input UTXO check is a strong
predicate about the state $\sigma$, essentially constraining a subset of it to
match our expectations, this allows quite strong predicates to be constructed on
the right hand side of this implication.

### DoS Protection

DoS protection is provided by:
* The subset check being cheap (assuming a constant bound on the UTXO set).
* The simple input validation being cheap.

### Consistency

We can derive much stronger postconditions while satisfying consistency, due to the ability of deriving strong preconditions.

### Compressability

As Hydra takes advantage of, any series of transactions can be compressed by
removing any UTXOs that are both produced and consumed between them. This
assumes data is arranged such that the transactions being compressed *do* share
inputs and outputs, however under that condition.

### Contention Resistance

The eUTXO models performs poorly at contention resistance under certain
conditions: Although any stateful object can be emulated with a UTXOs data
field, any two transactions operating on the same UTXO are in contention, and
cannot be applied in sequence. As users are likely to operate on UTXOs which
they observe, there is a reasonably high chance that transactions
$\tau_1, \tau_2 \xleftarrow{*} \mathcal{H}(\sigma)$ are contentious.

## Read-then-write ADTs

Suppose we generalize from $\sigma$ being a set to $\sigma$ being an arbitrarily
nested ADT over builtin types. Such types might include:
* Sets
* Lists
* Merkle trees
* Counters
* Records
* Vectors
* Primitive data types

These ADTs have operations which can broadly be split into *reads*, *writes* (or
updates), and *refinements*. The latter would be focusing on a specific part of
the ADT, e.g. a specific record field, and can contain either reads, writes, or
refinements themselves, making up a read or write overall. (Note: This
corresponds to Lenses in Optics, and raises a question: Is there an equivalent
for Prisms?) Crucially, *writes* are effectful, but *cannot fail*.

Once this structure is imposed on state, we can require that a transaction $\tau$ consists of (in order):
* Any number of ADT reads, each with complexity $O(1)$
* Any number of ADT writes, with arbitrary complexity

A transaction is applied by first checking that all the reads match those
recorded in the transaction. If they do, the writes are carried out, if not, the
transaction has not effect.

### Fairness

As fee payment is an update, and updates either all get carried out or none do,
fairness is guaranteed. Note that the precondition predicates expressible
through ADTs is strictly stronger than those in eUTXO, which can be seen as a
set ADT.

### DoS Protection

DoS protection is provided by a transaction succeeding being determined by all
ADT reads succeeding, which for $n$ reads is $O(n)$.

### Consistency

As with eUTXOs, we can derive strong postconditions.

### Compressability

We can derive *rewrite rules* for sequences of ADT interactions. Examples of these might be:
* `add a || add b = add (a + b)`
* `write a || write b = write b`
* `read a || write a = read a`

Ultimately, any part of the state ADT could be compressed into a single `read`
query followed by a single `write` query, therefore large numbers of localized
accesses are likely to be highly compressible.

### Contention Resistance

ADTs should provide better contention than eUTXO, due to allowing more
flexibility in the assertions that can be made about the state at any time. In
particular, it is possible for multiple ADT accesses to target the same part of
the overall state while not conflicting with each other.

## Maximally Programmable $V$

Another idea is to optimise $V$ to be maximally programmable—what is the
broadest class of programs that it can capture, while preserving the DoS
constraint that $V(\tau, \sigma) \in O(|\tau|)$?

Suppose a transaction consisted just of an encoding of $V$ and a correctness
proof. A reasonable way to achieve the execution time bounds would simply be to
have the language for $V$ be a low-level language without loops, such as SSA (or
Abcird!). This language *would* need to be able to perform stateful (and $O(1)$)
accesses to $\sigma$. These accesses themselves could fall under the above ADT
approach.

*Differences to ADT approach:*
1. It is possible to apply custom predicates to ADT results
2. It is possible to perform state writes in $V$
3. It is possible to perform branching and variable binding in $V$

$V$ could be followed by an arbitrary cost, write/update-only function, or it
could be standalone. The latter would allow a case where *normal transactions do
not pay any gas*.

### Fairness

Applying $V$ would be all-or-nothing, providing fairness for predicates
expressible in the language for $V$. This language is strictly stronger than
eUTXO and ADTs, but strictly weaker than a Turing-complete one.

### DoS Protection

DoS protection is provided by $V$ being $O(|V|)$.

### Consistency

As before, we can derive strong postconditions.

### Compressability

This fully depends on the compressability of $V$. This starts to look like a compiler optimization problem.

### Contention Resistance

As this permits the strongest possible language for precondition predicates, this should minimize contention.

## Read set

### Notation

Let $\mathcal{O}$ be a public oracle with an internal state $\sigma \in V^L$. Let $\delta(q, \sigma) = \sigma'$ be the oracle transition function which executes query $q$. The transition function $\delta$ is expressed in language $\mathcal{L}$. Let $t \in T$ be a transaction. Then the read set for $(t, \sigma)$ is $$R(t, \sigma) = \bigcup_{i = 0}^n \{ (l, v) \mid l \in L \wedge v \in V \wedge \delta(q_i, \sigma_i) \text{ reads } v \text{ from } l \text{ before any write to } l \text{ occurs } \}$$ where each $q_i$ is a query made to a public oracle, $\sigma_o = \sigma$ and the intermediate states $\sigma_j$ are carried through. This set is roughly the set of source verticies in the dependency graph for the public oracle execution. Assume that the read set can be computed during the evaluation of $\Delta(t, \sigma)$.

Let $\sigma_A$ be the public state of the client and $\sigma_B$ be the public state of the node. Then define the node quick-check predicate as follows. $$V(t, \sigma_B) = \bigwedge_{(l, v) \in R(t, \sigma_A)} \sigma_B(l) = v$$

In other words, $R(t, \sigma_{A})$ defines the substate of $\sigma_A$ and $\sigma_B$ must match for $t$ to be applicable.

### Properties

1. **Fairness** Trivially. We can always revert $\sigma_B'$ to $\sigma_B$.

2. **DoS Protection** Let $P(t, \sigma)$ be the predicate that tests if a transcript was applied successfully. Given that $V(t, \sigma)$ is true and $\delta$ is deterministic, $\Delta(t, \sigma_A)$ and $\Delta(t, \sigma_B)$ should be equivalent with respect to the state locations updated by $t$. In other words, for all honest $t$, $V(t, \sigma) \implies P(t, \sigma)$. Furthermore, $V(t, \sigma) \in O(n)$ since each equality check is $O(1)$.

3. **Consistency** Post condition is that $\Delta(t, \sigma_A) =_W \Delta(t, \sigma_B)$. That is, the two resulting states are equivalent with respect to the locations written by $t$.

4. **Compressability** The compressability property needs to be elaborated. If public oracle queries are just ADT operations implemented in $\mathcal{L}$, then should have similar compressability to ADT approach. Could also investigate possibility of using Ethereum-style state roll-ups.

5. **Contention Resistance** Because the read set is calculated automatically for a given execution, it may contain entries that cause a transaction to be rejected even if the transaction's transcript would succeed if applied. This issue does not exist in the ADT approach because the initial read sequence of the transcript is programmed by the developer. 

### Assumptions

1. The language $\mathcal{L}$ to express $\delta$ will be restricted to a language that is suitable for our domain, at least allowing basic assignments and branching.

### Observations

1. The ADT approach still requires a fee schedule, but it may be more difficult to attach costs to ADT operations than we anticipate. For example, binary search tree insertions have $O(\text{log } n)$ average case complexity and $O(n)$ worst case complexity. How then should we charge for insertions? It seems unlikely that we could attach a fixed cost to such operations, or even use a more sophisticated calculation that is fair and cheap.

### Benefits

1. Potential to reduce circuit size, therefore proving time, and therefore transaction latency. Some transition functions which have branching logic based on the results of queries could be written such that branching logic is executed within public oracle queries.

2. Permits using future static analysis tools to minimize the change set included in the transaction.

3. Subsumes the ADT approach if all ADT operations are expressible in $\mathcal{L}$.

4. Transcripts only have one purpose, and doesn't require user to manually specify the initial read query sequence.

5. Possibly more extensible. If language is restricted to pre-defined ADTs, introducing new ADTs (a fairly regular occurrence) will require more frequent updates that changes/corrections to the semantics of $\mathcal{L}$.

## Costs

1. Requires an additional compiler and interpreter, as well as more complex development environment.

2. Makes transaction semantics more complex; an ADT language with a fixed set of operations requires no public oracle code distribution, whereas $\mathcal{L}$ might require a public oracle executable to be included in the deploy transaction.

3. Less contention resistant than ADT approach when multiple parties touch the same state location.

4. Query compression becomes more complex as the implemented public oracle queries become more complex.

# Desired Result

Our solution should satisfy properties 1. through 5. without compromising programmability.

