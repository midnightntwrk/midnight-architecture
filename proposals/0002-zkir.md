# Proposal 0002: ZKIR

This might be a slightly _franken-proposal_, because there are multiple problems
that we are trying to solve with ZKIR, so we might end up splitting this
proposal into multiple smaller ones.

**NOTE** To avoid confusion, I will use transition-function (TF) for smart
contracts written in Abcird, instead of using the usual smart-contracts (SC).

This proposal focuses on executing TFs in the following contexts:
- by developer when they write their own TFs in Abcird,
- by client when they call a deployed TF,
- by node when they verify TF call transactions, and finally
- by client if they want to verify a new TF call transaction that appeared on
  chain.

# Problem 1: Cannot Ship Rust Compiler as a Part of the Node

We are using [ZK-Garage/plonk](https://github.com/ZK-Garage/plonk) as our
underlying proving system.  ZK-Garage/plonk is a pure Rust implementation of the
Plonk proving system.  It is essentially an embedded DSL in Rust for writing
Plonk circuits.  Therefore, ZK-Garage/plonk depends on Rust toolchain:

- circuits and gadgets are Rust programs,
- field elements are Rust structures,
- field operations are performed by Rust libraries,
- builtins are written in Rust, and
- the actual computation that needs to be proven using ZK is written in Rust.

In Midnight there are multiple points where one might want to compile a ZK
circuit, especially due to zero-trust assumptions:

- developer when writing their own TF,
- client when calling a TF,
- node when verifying a call TF transaction, before accepting it on the chain,
- client when observing new call TF transactions on the chain.

## Problem Statement

While it would be possible to require developers to use Rust toolchain, it is
not feasible to require that client and node depend on Rust toolchain to use
Midnight for various reasons (security, portability, performance, etc).


## Proposed Changes

Therefore we propose Zero-Knowledge Intermediate Representation (ZKIR) which is:

- a well defined and versioned format for low-level representation of transition
  functions, and
- an interpreter for the above format that can load it and produce a plonk
  circuit out of the aforementioned representation, which is packaged as
- a portable and statically linked library in Rust, that can be easily used
  within native programs and in WASM.


## Desired Result

We have a single artifact that we can provide to

- developers, as source code,
- node, as statically linked binary, and
- client, as WASM library.


# Problem 2: Exposing ZKIR Intrinsics

Abcird programs refer to functionalities that are implemented in Rust by providing:
- a field type, and
- hashing operations.

Furthermore, in the future, Abcird may provide more builtin operations that
ideally would be implemented in Rust, such as operations on native tokens.

In order to execute a TF (and any code which uses ZKIR intrinsics, which might
include Public Oracle as well) we need to be able to execute those ZKIR
intrinsics.

## Problem Statement

It would be unfeasible to port ZKIR intrinsics to TypeScript (or every other
language that we want to write dApps in).  Even if we did reimplement those
intrinsics in TypeScript, then it would put an additional maintenance burden to
ensure that both implementations of intrinsics are not deviating from one
another.  Such deviation would be potentially catastrophic, as it would silently
corrupt TF executions in unpredictable ways.

## Proposed Changes

We can approach the problem of calling ZKIR Intrinsics from two separate angles.

### Solution A: TypeScript Wrapper for ZKIR Intrinsics

If we compile Abcird TFs to TypeScript, then we could provide ZKIR Intrinsics as
a library that can be called from TypeScript, probably as a WASM library.  This
approach is easier as we will have both the Private Oracle and TF in TypeScript,
but we depend on TypeScript to run TFs.

### Solution B: ZKIR Interpreter

If we compile Abcird TFs to ZKIR, then we could provide a full blown ZKIR
Interpreter that can be called from TypeScript, again probably as a WASM
library.  This approach is more difficult as:

* it would need to provide a way to call into Private and Public Oracle from a WASM library,
* it would be more complicated that Solution A (both including coding and debugging),

but we would have portable runtime for TFs, running in Rust/WASM.

## Desired Result

We have a way to call ZKIR Intrinsics from within TypeScript so we can execute
TF in the browser.

# Problem 3: Plonk Upgradeability

ZK-Garage/plonk is still in active development.  Different Plonk
instances are not compatible with each other.

## Problem Statement

A potential upgrade to our underlying proving system or adding new Plonk custom
gate will make the old proofs incompatible.

## Proposed Changes

Compile Abcird programs to a versioned ZKIR, and publish TFs as such.

## Desired Result

We can survive an upgrade to the underlying proving system without the need to
run the abcird compiler on every TF functions that was deployed on the
blockchain.
