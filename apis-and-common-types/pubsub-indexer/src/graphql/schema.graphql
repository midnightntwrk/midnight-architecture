schema {
    query: Query
    subscription: Subscription
}

type Query {
    block(offset: BlockOffset!): Block
    transaction(hash: TransactionHash!): Transaction
    contractState(address: ContractAddress!): ContractState
}

type Subscription {
    contractState(address: ContractAddress!, offset: BlockOffset!): ContractCalled
    viewingKey(key: ViewingKey!, offset: BlockOffset!): Transaction
}

# Not possible to use unions as input types, so using 2 optional fields
input BlockOffset {
    hash: BlockHash
    height: BlockHeight
}

type Block {
    hash: BlockHash!
    parentHash: BlockHash!
    height: BlockHeight!
    timestamp: DateTime!
    transactions: [Transaction!]!
}

type Transaction {
    hash: TransactionHash!
    blockHash: BlockHash!
    nullifiers: [Nullifier!]!
    commitments: [Commitment!]!
}

type ContractCalled {
    address: ContractAddress!
    transaction: Transaction!
    newState: ContractState!
}

type NewNullifiers {
    transaction: TransactionHash!
    nullifiers: [Nullifier!]!
}

type NewCommitments {
    transaction: TransactionHash!
    commitments: [Commitment!]!
    rootHash: MerkleTreeHash!
}

scalar BlockHash

scalar BlockHeight

scalar TransactionHash

scalar Nullifier

scalar Commitment

scalar ContractAddress

scalar ContractState

scalar ViewingKey

scalar MerkleTreeHash

scalar DateTime
