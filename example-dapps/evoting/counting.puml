@startuml
autonumber

'-----------------------------------------------------------
' Please include this standard header
header %filename()\n%date("yyyy.MM.dd' at 'HH:mm z")\n\n\n
'-----------------------------------------------------------

!include example-dapps/evoting/participants.puml

hnote over state #aqua
        • phase = COUNTING
end note


note over B #lightyellow
        Assume Voter B has a confirmed VOT token
        //v// that committed to option //o//.  B
        learns the contract is in the COUNTING state
        and chooses to spend //v// and increment
        the tally for option //o//.
end note

hnote over rho_b #aqua
        • keys = ⟨pk[B],sk[B]⟩
        • **verified** VOT //v//
             with option //o//
end note


verifier -> B : state //s// with phase = COUNTING
activate B
        B -> rho_b ++ : Count(//v//, code, circuits, //s//)
        note over rho_b #lightyellow
                Create a commitment to "spend" the
                given VOT token //v// with no output
                token but, instead, the effect of
                incrementing the tally count for
                option //o//.  Proves of validity of
                the commitment //wrt// state s,
                ensuring //v// is truly a vote for
                //o//.  Returns the proof and
                bytecode for updating the VOT
                nullifier set and tally dictionary
                in //s//.  The commitment is
                //pending// until witnessed under
                consensus.
        end note
        hnote over rho_b #aqua
                • **pending spend** VOT //v//
        end note
        return Counted(proof, public_bytecode)
        B -> verifier : Call(addr, public_bytecode, proof)
deactivate B

activate verifier
        verifier -> state ++ : Fetch(addr)
        return s'
        note over verifier #lightyellow
                In this case s = s', but
                Kachina assumes s ≠ s'
        end note
        verifier -> contracts ++ : Fetch(addr)
        return ⟨code, circuits⟩
        note over verifier #lightyellow
                Verify the ZK proof using the given
                circuits, proof, and state s'.  On
                success, compute a new state s''
                using inputs s' and the public_bytecode
                operations. On success, install the
                updated state.
        end note
        note over state #lightyellow
                The new state s'' includes
                everything from s' with the VOT
                token added to its nullifiers
                set and the tally dict's entry
                for option //o// incremented.
        end note
        verifier -> state : Update(addr, s'')
        hnote over state #aqua
                • VOT.nulls += v.hash
                • tally[//o//] ++
        end note
        verifier -> A: verifiedTx_3 //including B's encrypted nonce//
        note over A #lightyellow : ignore
        verifier -> C : verifiedTx_3 //including B's encrypted nonce//
        note over C #lightyellow : ignore
        verifier -> B : verifiedTx_3 //including B's encrypted nonce//
deactivate verifier

activate B
        B -> rho_b ++ : Apply(verifiedTx_3)
        note over rho_b #lightyellow
                B is able to decrypt the nonce
                using sk[B]. It marks the
                pending commitments as
                confirmed, ensuring B will not
                try to reuse //v// and that B
                now knows its vote for //o//
                has been counted in the final
                tally.
        end note
        hnote over rho_b #aqua
                • **spent** VOT //v//            
        end note
        rho_b --> B --: Counted(option)
deactivate B




'-----------------------------------------------------------
' Please include this standard footer
footer \n\n\nCopyright %date("yyyy"), Input Output Hong Kong, Ltd.
'-----------------------------------------------------------


@enduml
