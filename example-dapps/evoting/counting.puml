@startuml
autonumber

'-----------------------------------------------------------
' Please include this standard header
header %filename()\n%date("yyyy.MM.dd' at 'HH:mm z")\n\n\n
'-----------------------------------------------------------

!include participants.puml



note over B #lightyellow
        Assume Voter B has a confirmed VOT token
        //v// that committed to option //o//.  B
        learns the contract is in the COUNTING state
        and chooses to spend //v// and increment
        the tally for option //o//.
end note



verifier -> B : state //s// with phase = COUNTING
activate B
        B -> rho_b ++ : Count(//v//, //o//, code, circuits, //s//, sk[B])
        note over rho_b #lightyellow
                Create a commitment to "spend" the
                given VOT token //v// with no output
                token but, instead, the effect of
                incrementing the tally count for
                option //o//.  Proves of validity of
                the commitment //wrt// state s,
                ensuring //v// is truly a vote for
                //o//.  Returns the proof and
                bytecode for updating the VOT
                nullifier set and tally dictionary
                in //s//.  The commitment is
                //pending// until witnessed under
                consensus.
        end note
        return Counted(proof, public_bytecode)
        B -> verifier : Call(addr, public_bytecode, proof)
deactivate B

activate verifier
        verifier -> state ++ : Fetch(addr)
        return s'
        note over verifier #lightyellow
                In this case s = s', but
                Kachina assumes s ≠ s'
        end note
        verifier -> contracts ++ : Fetch(addr)
        return ⟨code, circuits⟩
        note over verifier #lightyellow
                Verify the ZK proof using the given
                circuits, proof, and state s'.  On
                success, compute a new state s''
                using inputs s' and the public_bytecode
                operations. On success, install the
                updated state.
        end note
        note over state #lightyellow
                The new state s'' includes
                everything from s' with the VOT
                token added to its nullifiers
                set and the tally dict's entry
                for option //o// incremented.
        end note
        verifier -> state : Update(addr, s'')
        verifier -> A: verifiedTx_3 //including B's encrypted token//
        verifier -> B : verifiedTx_3 //including B's encrypted token//
        verifier -> C : verifiedTx_3 //including B's encrypted token//
deactivate verifier

activate B
        B -> rho_b ++ : Apply(verifiedTx_3)
        note over rho_b #lightyellow
                B is able to decrypt the
                transaction using sk[B]. It
                marks the pending commitments
                as confirmed, ensuring B will
                not try to reuse //v// and that
                B now knows its vote for //o//
                has been counted in the final
                tally.
        end note
        rho_b --> B --: Counted(option)
deactivate B




'-----------------------------------------------------------
' Please include this standard footer
footer \n\n\nCopyright %date("yyyy"), Input Output Hong Kong, Ltd.
'-----------------------------------------------------------


@enduml
