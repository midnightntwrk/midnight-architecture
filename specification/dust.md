# Dust and fee payments

Dust operates similarly to, but separately from, [Zswap](./zswap.md). It
operates as the fee payment token of Midnight, but has the following unique
properties:

- Dust is generated over time from Night
- If no Night is generating the Dust, it decays over time
- Dust is a shielded token, but is not transferable, instead being usable only
  for fees.
- Dust is not persistent, the system may redistribute it on hardforks.

## Preliminaries

Similar to Zswap, Dust is built on hashes and the commitment/nullifier
paradigm. Differently to Zswap, Dust uses ZK-friendly hashes, as the
non-persistence of Dust allows these to be changed on hardforks.

```rust
type DustSecretKey = Fr;
type DustPublicKey = field::Hash<DustSecretKey>;
```

Dust does not need any encryption keys, as it is not transferred. This does
leave a question of wallet recovery, which [will be addressed
below](#wallet-recovery).

Core to this recovery is a deterministic evolution of nonces in Dust UTXOs. As
each Dust spend non-transferring, they are 1-to-1. Furthermore, the first Dust
in a chain always originates uniquely from a Night UTXO. We hash three things
to determine the nonce of a Dust UTXO:
- The intent hash and output number identifying its originating Night UTXO.
- A sequence number, starting at 0, indicating where we are in this chain of
self-spends.
- The owners public/secret key. For the first Dust UTXO, as this is created and
  publicly linked to the originating Night UTXO by necessity, this is the Dust
  public key. For all subsequent Dust UTXOs, this is the owner's Dust *secret*
  key, to ensure that only the owner can guess this nonce.

The core `DustOutput` type takes a similar role as Zswap's `CoinInfo`,
describing a single UTXO as it may appear in a user's wallet.

```rust
/// Hash uniquely identifying the originating Night UTXO
type InitialNonce = Hash<(IntentHash, u32)>;

struct DustOutput {
    /// The amount of atomic Dust units (Specks) held in this UTXO
    value: u128,
    /// The public key owning the Dust UTXO.
    owner: DustPublicKey,
    /// The nonce of this Dust UTXO
    nonce: field::Hash<(InitialNonce, u32, Fr)>,
    /// The current sequence number
    seq: u32,
    /// The creation time of this Dust UTXO
    ctime: Timestamp,
}
```

As with Zswap, Dust UTXOs have commitment and nullifier projections, here
defined over a variant of `DustOutput`:

```rust
struct DustPreProjection<T> {
    value: u128,
    owner: T,
    nonce: field::Hash<(InitialNonce, u32, Fr)>,
    ctime: Timestamp,
}

type DustCommitment = field::Hash<DustPreProjection<DustPublicKey>>;
type DustNullifier = field::Hash<DustPreProjection<DustSecretKey>>;
```

The core state of the Dust subsystem then consists, similarly to Zswap, of a
commitment Merkle tree, a nullifier set, and a history of valid Merkle tree
roots for proof verification.

```rust
struct DustUtxoState {
    commitments: MerkleTree<DustCommitment>,
    commitments_first_free: usize,
    nullifiers: Set<DustNullifier>,
    root_history: TimeFilterMap<MerkleTreeRoot>,
}
```

## Initial Dust parameters

Dust has a handful of fundamental parameters, which are given here both in
abstract, and in their concrete initial assignment. Fundamentally, these define
the relation between Night, Dust, and time.

Is is worth also being clear about the atomic units of Night and Dust here.
- The atomic unit of Night is the Star, with 1 Night = 10^6 Stars
- The atomic unit of Dust is the Speck, with 1 Dust = 10^15 Specks

Dust has a much higher resolution to allow more fine-grained fee payments,
while importantly being low enough that the maximum supply of Dust still fits
comfortably in a `u128`, eliminating (most) overflow concerns.

```rust
struct DustParameters {
    /// The maxmium supply of Specks per Star
    night_dust_ratio: u64,
    /// The number amount of Specks per Star per second to generate or decay.
    generation_decay_rate: u32,
    /// The amount of time that may pass before a Dust spend is forced to time out.
    dust_grace_period: Duration,
}
```

The initial assignment of these is given by the rough guidance of 5 Dust being
the maximum support per Night, and the generation time of 1 week. The grace
period is set to 3 hours, to allow for network congestion, but not transactions
living for days.

```rust
const INITIAL_DUST_PARAMETERS: DustParameters = {
    night_dust_ratio = 5_000_000_000; // 5 DUST per NIGHT
    generation_rate = 8_267; // Works out to a generation time of approximately 1 week.
    dust_grace_period = Duration::from_hours(3),
};
```

## Generating Dust

As stated, Dust is generated by Night over time. Technically this poses a
challenge, as Night uses different key material to Dust. In addition to this,
this address should be modifiable over time, to enable the use-case of leasing
out Dust generation.

This is primarily accomplished with a table linking Night and Dust addresses,
and additional processing behaviour on processing Night inputs and outputs.
For each input and output processed, a table of currently active Dust
generations is updated, this can then be referenced to determine the amount of
Dust held in any given UTXO. Additionally, each output processed creates a new
Dust UTXO.

The core information about one currently active Night UTXO generation is
encapsulated in `DustGenerationInfo`, which captures the amount of Night
(Stars) generating Dust, the public key they are generating Dust to, the nonce
at the start of the Dust chain, and finally, the time this Night UTXO was
spent. The final value is necessary as it's important for determining the value
of the corresponding Night to know when any decay started. This time may be set
in the future, and unspent Night will have a generation info with this set to
`Timestamp::MAX`.

```rust
struct DustGenerationInfo {
    value: u128,
    owner: DustPublicKey,
    nonce: InitialNonce,
    dtime: Timestamp,
}
```

In order to ensure that Dust generation is unique, a variant of this without
the timestamp is also kept in the state, preventing duplicate Dust generations.

```rust
struct DustGenerationUniquenessInfo {
    value: u128,
    owner: DustPublicKey,
    nonce: InitialNonce,
}
```

The state related to the Dust generation information has a number of
components:
- A mapping from Night to Dust addresses to link new outputs with.
- A sequential Merkle tree of `DustGenerationInfo`, which can be directly used
  to provide the presence of a specific Dust generation info in ZK proofs.
- A corresponding set of the `DustGenerationUniquenessInfo`s, to prevent
  collisions in these.
- A mapping from Night UTXOs to their position in the Merkle tree.
- A history of valid Merkle tree roots (valid for the Dust grace period).

```rust
struct DustGenerationState {
    address_delegation: Map<NightAddress, DustPublicKey>,
    generating_tree: MerkleTree<DustGenerationInfo>,
    generating_tree_first_free: usize,
    generating_set: Set<DustGenerationUniquenessInfo>,
    night_indices: Map<Utxo, u64>,
    root_history: TimeFilterMap<MerkleTreeRoot>,
}
```

The address map itself is updated with 'registrations', signed by a Night
address (via its signature verifying key), and either linking a specific Dust
address, or removing the existing link. Registrations may also permit the
containing transaction from taking some amount from *unclaimed* Dust associated
with this Night address to be used to cover the transaction's fees.

```rust
struct DustRegistration<S> {
    night_key: VerifyingKey,
    dust_address: Option<DustPublicKey>,
    /// The amount of fees from owed DUST that this registration will cede to
    /// fee payments. This *must* be an underestimate of the fees available.
    allow_fee_payment: u128,
    Signature,
}

```

## Dust value & spends

Core to the experience of Dust is the change in value of a Dust UTXO over time.
If there is a backing Night UTXO (and all Dust UTXOs *initially* have a backing
Night UTXO), the value of the Dust UTXO will approach a maximum deteremined by
the Night-Dust ratio, and the value of the backing Night. After the backing
Night UTXO has been marked as destroyed, its value instead approaches zero over
time.

When spending a Dust UTXO, it's 'current' value, with respect to a timestamp
representing the current time has to be computed. This may include both
generating and decaying phases. Specifically, we split the elapsed time into
(at most) four linear segments:

1. Generating, from the Dust UTXO's creation time, to the sooner of the time it
   reaches capacity and the time the backing Night UTXO is spent.
2. Constant at maximum capacity, from the time reaching maximum capacity (if
   applicable) to the time the backing Night UTXO is spent.
3. Decaying, from the latter of the Dust UTXO's creation time, and time the backing Night UTXO is spent, to the time Dust reaches zero value.
4. Constant at zero, for the rest of time.

This relies on the fact that a Dust UTXO cannot regain a backing Night UTXO;
that would create a *new* Dust UTXO instead.

```rust
fn updated_value(
    inp: DustOutput,
    gen: DustGenerationInfo,
    now: Timestamp,
    params: DustParameters,
) -> u128 {
    // There are up to four linear segments:
    // 1. Generating (from inp.ctime to tfull, the time dust fills to the cap)
    // 2. Constant full (from tfull to gen.dtime)
    // 3. Decaying (from gen.dtime to tempty, the time dust reaches zero)
    // 4. Constant empty (from tempty onwards)
    // 
    // If gen.dtime <= tfull, phase 3. doesn't occur, and if gen.dtime <=
    // inp.ctime Phase 1 doesn't occur.
    //
    // We assume that the full value is gen.value * night_dust_ratio, and that
    // the time to fill is dust_ttl
    let vfull = gen.value * params.night_dust_ratio;
    // Note that `night_dust_ratio / time_to_gen` can be an input, not
    // requiring division in-circuit.
    let rate = gen.value * generation_decay_rate;
    // Note that we aren't constraining the end to be after the start, instead
    // we're clamping the output to the reasonable region of outputs.
    let tstart_phase_1 = inp.ctime;
    let tend_phase_1 = min(gen.dtime, now);
    let value_phase_1_unchecked = (tend_phase_1 - tstart_phase_1).as_seconds() * rate + inp.value;
    let value_phase_1 = clamp(value_phase_1_unchecked, inp.value, vfull);
    // Again, we aren't constraining the end to be after the start, instead
    // we're clamping the output to the reasonable region of outputs.
    let tstart_phase_3 = gen.dtime;
    let tend_phase_3 = now;
    let value_phase_3_unchecked = value_phase_1 - (tend_phase_3 - tstart_phase_3).as_seconds() * rate;
    let value_phase_3 = clamp(value_phase_3_unchecked, 0, value_phase_1);
    value_phase_3
}
```

The main means for making use of Dust is by *spending* it. This is in some ways
similar to a combined Zswap spend and output, with the additional computation
of the *updated* value using `updated_value`, and a constraint that the owner
of the input and the owner of the output match. The spend also declares a *fee*
value, which is subtracted from the created output. This is the amount of fees
this Dust spend covers.

As opposed to Zswap, the Dust spend does not directly reference the Merkle tree
root it proves inclusion in. This is because Dust already has a strong
requirement on time, which needs to be within the `dust_grace_period`, and is
already used to calculate the updated value. As a result, this timestamp is
used as a key to retrieve the corresponding Merkle tree, rather than including
this in the transaction.

```rust
struct DustSpend<P> {
    v_fee: u128,
    nullifier: DustNullifier,
    commitment: DustCommitment,
    proof: P::Proof,
}
```

The zero-knowledge proof in the Dust spend is then validated against not just the spend itself, but also:
- The declared timestamp
- The dust parameters to use
- The Merkle tree roots associated with the Dust commitment tree, and the
  generation information tree, corresponding to the declared timestamp.

Locally, users need to supply:
- The Dust UTXO that is being spent
- The Dust secret key demonstrating ownership
- The backing generation info
- The paths to both the Dust commitment being spent, and the generation info.
- The nonce and sequence number of the new output.

```rust
fn dust_spend_valid(
    dust_spend: Public<DustSpend<()>>,
    tnow: Public<Timestamp>,
    params: Public<DustParameters>,
    commitment_root: Public<MerkleTreeRoot>,
    generation_root: Public<MerkleTreeRoot>,
    dust: Private<DustOutput>,
    sk: Private<DustSecretKey>,
    gen: Private<DustGenerationInfo>,
    commitment_merkle_tree: Private<MerkleTree<DustCommitment>>,
    generation_merkle_tree: Private<MerkleTree<DustGenerationInfo>>,
    // Note these are for the new coin, and there is no need to validate these,
    // as the secret key ensures these are provided by the same user as consumes
    // them.
    initial_nonce: Private<InitialNonce>,
    seq_no: Private<u32>,
) -> bool {
    assert!(dust.owner == field::hash(sk));
    let pre_commitment = field::hash(DustPreProjection {
        value: dust.value,
        owner: dust.owner,
        nonce: dust.nonce,
        ctime: dust.ctime,
    });
    assert!(commitment_merkle_tree.contains(pre_commitment));
    assert!(commitment_root = commitment_merkle_tree.root());
    assert!(generation_merkle_tree.contains(gen));
    assert!(genration_root = generation_merkle_tree.root());
    let nullifier = field::hash(DustPreProjection {
        value: dust.value,
        owner: sk,
        nonce: dust.nonce,
        ctime: dust.ctime,
    });
    assert!(dust_spend.nullifier == nullifier);
    let v_pre = updated_value(inp, gen, tnow, params);
    assert!(dust_spend.v_fee >= v_pre);
    let v = v_pre - dust_spend.v_fee;
    let nonce = field::hash((initial_nonce, seq_no, sk));
    let post_commitment = field::hash(DustPreProjection {
        value: v,
        owner: dust.owner,
        nonce,
        ctime: tnow,
    });
    assert!(dust_spend.commitment == post_commitment);
}
```

Well-formedness for dust spends is just proof verification, using the parent
intent's binding commitment to bind to, and a parent timestamp to look up
Merkle trees in the dust state. Said dust state is defined simply to consist of
the parameters, Dust UTXO state, and Dust generation state.

```rust
struct DustState {
    utxo: DustUtxoState,
    generation: DustGenerationState,
    params: DustParameters,
}

impl<P> DustSpend<P> {
    fn well_formed(self, ref_state: DustState, segment: u16, binding: Pedersen, tparent: Timestamp) -> Result<()> {
        assert!(zk_verify(
            dust_spend_valid,
            (
                self,
                tparent,
                ref_state.parameters,
                ref_state.utxo.root_history.get(tparent),
                ref_state.generation.root_history.get(tparent),
            ),
            Some((segment, binding)),
            self.proof,
        ));
    }
}
```

## Dust actions

As part of an intent, there are three ways to influence the state of the Dust
subsystem:
- By transacting in Night, which affects the Dust generation state, and creates
  fresh Dust UTXOs.
- By making `DustSpend`s, which explicitly transact on Dust UTXOs.
- By making `DustRegistration`s, which both affect the Night/Dust address
  mapping, and may affect the Dust generation state nad create fresh Dust UTXOs
  if the relevant Night address has Night UTXOs owed Dust in this transaction.

The latter two are captured in an explicit `DustActions` structure, which also includes a timestamp that these actions are made against.

The `DustRegistration`s case is the complex one, because these registrations
*may* pay for fees. This has a several preconditions, and differently from the
other operations, happens sequentially. In particular, for a registration to
pay for fees, the relevant Night address must have both Night inputs and
outputs present in this transaction, and at least one of the inputs must not
have already been generating Dust. In that case, the Dust these inputs *would
have generated* will be used to cover transaction fees, up to the declared
limit, and the remaining amount distributed across the outputs.

However, if other parts of the transaction already sufficiently cover the fees,
additional Dust over the requirement is not taken, and the amount distributed
is correspondingly higher. This is in contrast with `DustSpend`s, as their
privacy doesn't (without additional cost) allow for partial refunds.

Registrations are processed sequentially, and in order of their corresponding
`Intent`s segment ID. Note that as fee payments are processed during the
guaranteed segment, this process only affects inputs and outputs in this
segment. Further, to minimize the amount of fees taken, all segments
`DustSpend`s are processed first, then then the Dust registrations are proessed
in sequence.

```rust
struct DustActions<S, P> {
    spends: Vec<DustSpend<P>>,
    registrations: Vec<DustRegistration>,
    ctime: Timestamp,
}
```

A `DustAciton` is well-formed if its parts are well formed, there are no
duplicate registrations, we are withing a `dust_grace_period` time window
of the declared timestamp, and all `DustRegistration`s have enough funds to
cover their declared fee bound.

```rust
impl<S, P> DustActions<S, P> {
    fn well_formed(
        self,
        ref_dust_state: DustState,
        ref_utxo_state: UtxoState,
        segment: u16,
        parent: ErasedIntent,
        tnow: Timestamp,
        params: DustParameters,
    ) -> Result<()> {
        let binding = parent.binding_commitment;
        assert!(!self.spends.is_empty() || !self.registrations.is_empty())
        for spend in self.spends {
            spend.well_formed(ref_state, segment, binding, self.ctime)?;
        }
        assert!(self.ctime <= tnow && self.ctime + params.dust_grace_period >= tnow);
        // Make sure that we are not registering for the same night key more
        // than once
        let mut night_keys = self.registrations
            .iter()
            .map(|reg| reg.night_key)
            .collect::<Vec<_>>();
        night_keys.sort();
        assert!(night_keys.windows(2).all(|window| window[0] != window[1]));
        // Make sure that each registration has sufficient unclaimed night in
        // the ref utxo state to cover its allowed fee payment field.
        assert!(self.registrations
            .iter()
            .filter(|reg| reg.allow_fee_payment > 0)
            .all(|reg|
                ref_dust_state.generationless_fee_availability(
                    ref_utxo_state,
                    parent,
                    reg.night_key,
                    params,
                ).unwrap_or(0) >= reg.allow_fee_payment
            )
        );
    }
}

impl DustState {
    fn generationless_fee_availability(
        self,
        utxo_state: UtxoState,
        parent_intent: ErasedIntent,
        night_key: VerifyingKey,
        params: DustParameters,
    ) -> Result<u128> {
        let generationless_inputs = parent_intent.guaranteed_unshielded_offer
            .iter()
            .flat_map(|o| o.inputs.iter())
            .filter(|i| i.owner == night_key && i.type_ == NIGHT_RAW)
            .filter(|i| !self.generation.night_indices.contains(Utxo::from(i)))
            .collect();
        generationless_inputs.iter().map(|i| {
            // In parallel with `updated_value`, but only phase 1
            let vfull = i.value * params.night_dust_ratio;
            let rate = i.value * params.generation_decay_rate;
            let tstart = utxo_state.get(Utxo::from(i))?.ctime;
            let tend = parent_intent.dust_actions
                .expect("Dust actions must exist to process a generationless fee availability")
                .ctime;
            let value_unchecked = (tend_phase_1 - tstart_phase_1).as_seconds() * rate;
            clamp(value_unchecked, 0, vfull)
        }).sum()
    }
}
```

Applying Dust spends straightforwardly adds both the old Dust UTXO's nullifier,
and the new Dust UTXO's commitment to the corresponding set / Merkle tree,
while ensuring they are not already present.

```rust
impl DustState {
    fn apply_spend<P>(mut self, spend: DustSpend<P>) -> Result<Self> {
        assert!(!self.utxos.nullifiers.contains(spend.nullifier));
        self.utxo.nullifiers = self.utxo.nullifiers.insert(spend.nullifier);
        self.utxo.commitments = self.utxo.commitments.insert(self.utxo.commitments_first_free, spend.commitment);
        self.utxo.commitments_first_free += 1;
        Ok(self)
    }
}
```

Applying unshielded offers to the Dust state processes Night inputs and outputs by:
- Setting the `dtime` on the corresponding `DustGenerationInfo` for a Night
  input (if it exists).
- If registration information for the recipient of a Night ouput exists:
  - Create a new `DustGenerationInfo` for this Night UTXO.
  - Create a fresh Dust UTXO, and insert this into the state.
- Outputs coverd by a new Dust registration are *not* processed here, but are
  processed with that registration instead.

```rust
impl DustState {
    fn apply_offer<S, P>(
        mut self,
        offer: UnshieldedOffer<S>,
        segment: u16,
        parent: ErasedIntent,
        tnow: Timestamp,
    ) -> Result<Self> {
        for input in offer.inputs.filter(|i| i.type_ == NIGHT_RAW) {
            let Some(idx) = self.generation.night_indices.get(Utxo::from(input)) else { continue; };
            let mut gen_info = self.generation.generating_tree
                .get(idx)
                .expect("Invalid index should not be in night indices");
            gen_info.dtime = tnow;
            self.generation.generating_tree = self.generation.generating_tree.insert(idx, gen_info);
        }
        for (output_no, output) in offer.outputs
            .iter()
            .enumerate()
            .filter(|(_, o)| o.type_ == NIGHT_RAW)
        {
            let Some(dust_addr) = self.generation.address_delegation.get(output.owner) else { continue; };
            let handled_by_registration = segment == 0 && parent.dust_actions
                .iter()
                .flat_map(|actions| actions.registrations.iter())
                .any(|reg| hash(reg.night_key) == output.owner);
            if !handled_by_registration {
                self = self.fresh_dust_output(segment, parent, 0, output_no as u32, output)?;
            }
        }
        self
    }


    fn fresh_dust_output(
        mut self,
        segment: u16,
        parent: ErasedIntent,
        initial_value: u128,
        output_no: u32,
        output: UtxoOutput,
    ) -> Result<Self> {
        let initial_nonce = hash(hash(segment, parent), output_no as u32);
        let seq = 0;
        let dust_pre_projection = DustPreProjection {
            value: initial_value,
            owner: dust_addr,
            nonce: field::hash((initial_nonce, seq, dust_addr)),
            ctime: tnow,
        };
        let dust_commitment = field::hash(dust_pre_projection);
        self.utxo.commitments = self.utxo.commitments.insert(
            self.utxo.commitments_first_free,
            dust_commitment,
        );
        self.utxo.commitments_first_free += 1;
        let gen_info = DustGenerationInfo {
            value: output.value,
            owner: dust_addr,
            nonce: initial_nonce,
            dtime: Timestamp::MAX,
        };
        let utxo = Utxo {
            value: output.value,
            owner: output.owner,
            type_: output.type_,
            intent_hash: hash(segment, parent),
            output_no,
        };
        assert!(!self.generation.generating_set.contains(gen_info.into()));
        self.generation.generating_set = self.generation.generating_set.insert(
            gen_info.into(),
        );
        self.generation.generating_tree = self.generation.generating_tree.insert(
            self.generation.generating_tree_first_free,
            gen_info,
        );
        self.generation.night_indices.insert(
            utxo,
            self.generation.generating_tree_first_free,
        );
        self.generation.generating_tree_first_free += 1;
    }
}
```

Dust registrations are processed by updating the Night/Dust address map, and
then processing remaining fees as declared above. As part of this process, fees
are diveded weighted by output UTXO values, this is done with a limited
resolution to prevent overflow or reliance on floating point math.

```rust
impl DustState {
    // Returns the updated self, and the updated `remaining_fees`.
    fn apply_registration<S>(
        mut self,
        utxo_state: UtxoState,
        mut remaining_fees: u128,
        parent_intent: ErasedIntent,
        reg: DustRegistration<S>,
        params: DustParameters,
    ) -> Result<(Self, u128)> {
        let night_address = hash(self.night_key);
        match reg.dust_address {
            None => {
                let entry = self.generation.address_delegation.remove(night_address);
                assert!(entry.is_some());
            },
            Some(dust_addr) => self.generation.address_delegation.insert(night_address, dust_addr),
        }
        let owned_outputs = parent_intent.guaranteed_unshielded_offer
            .iter()
            .flat_map(|o| o.outputs.iter().enumerate())
            .filter(|(_, o)| o.owner == night_address && o.type_ == NIGHT_RAW)
            .collect();
        let dust_in = self.generationless_fee_availability(utxo_state, parent_intent, reg.night_key, params)?;
        let fee_paid = u128::min(remaining_fees, u128::min(reg.allow_fee_payment, dust_in));
        remaining_fees -= fee_paid;
        let dust_out = dust_in - fee_paid;
        if let Some(dust_addr) = reg.dust_address {
            let output_sum = owned_outputs.iter().map(|o| o.value).sum();
            for (output_no, output) in owned_outputs {
                // NOTE: The ratio calculation could overflow even u128. As a
                // result, we quantize it.
                const DISTRIBUTION_RESOLUTION: u128 = 10_000;
                let ratio = ((output.value * DISTRIBUTION_RESOLUTION) / output_sum);
                let initial_value = (ratio * dust_out) / DISTRIBUTION_RESOLUTION;
                self = self.fresh_dust_output(0, parent_intent, initial_value, output_no as u32, output)?;
            }
        }
        Ok((self, remaining_fees))
    }
}
```

Finally, the post block update process for Dust state updates the Merkle tree
root history with the current tree, and filters our trees out of range.

```rust
impl DustState {
    fn post_block_update(mut self, tblock: Timestamp) -> Self {
        self.utxo.root_history = self.utxo.root_history.insert(
            tblock,
            self.utxo.commitments.root(),
        ).filter(tblock - global_ttl);
        self.generation.root_history = self.generation.root_history.insert(
            tblock,
            self.generation.generating_tree.root(),
        ).filter(tblock - global_ttl);
        self
    }
}
```

## Wallet recovery

For wallet recovery, the first step is to find owned Night UTXOs. This informs
the wallet of the *start* of any Dust UTXO chains, and the wallet can now
search linearly for the commitments associated with each sequence number in the
chain. The last such sequence number *should* be unspent.

Note that as this *does* link the given commitments to the indexing service
used, we suggest instead a stochastic privacy approach. Instead of quering
whether commitments are in the state, the wallet should query commitments
*starting with* a specific bit prefix, with the indexing service returning the
list of matching commitments, which the wallet can filter locally. The prefix
length should be determined from the number of total commitments, such that the
response includes however many commitments are sufficiently statistically
hiding for this wallet user.

For instance, if there are $2^14$ commitments in the state, and the wallet
wants an anonymity set of $2^7$, then it should send prefixes of $14 - 7 = 7$
bits.
