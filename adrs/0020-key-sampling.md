# 20 - Key sampling

## Status

Approved

---
| -         | -                                                   |
|-----------|-----------------------------------------------------|
| date      | July 9th, 2024                                      |
| deciders  | Thomas Kerber, Andrzej Kopeć                        |
| consulted | Iñigo Querejeta Azurmendi                           |
| informed  | Agron Murtezi, Enrique Rodriguez, Vanessa Cristobal |
---

## Context and Problem Statement

Midnight keys need to be derived from a seed or, using zcash vocabulary "spending key" in a specified, implementation-independent way, so that Wallet Builders in the ecosystem can implement the derivation on their own, replicating our results, if technology stack does not allow to use our implementation.

While it is a trivial concern for keys, which are arbitrary bytes, it becomes a more complex issue for keys, which are e.g. field elements - and thus - need to fit to space, which does not directly map to output of a hash function. 

## Decision Drivers

* Easy to specify
* Easy to implement securely
* Good coverage of arbitrary field

## Considered Options

All considered options can be easily expressed as a Cartesian product of 3 dimensions (some are nonsensical though)
1. Whether to sample by rejection or by construction
2. If multiple hashes are needed - whether to chain them through iteration (like CTR mode in block ciphers) or by taking result from previous stage (like CBC in block ciphers)
3. Whether to ensure generated bytes fit into field by exact size or taking modulo

## Decision Outcome

Chosen option: 
- to sample by construction needed number of bytes + constant of 16 bytes
- chaining by iteration
- ensuring generated values fits into field by converting generated bytes into a scalar and taking modulo field size 

because this option matches all criteria and of all options considered this seems to be the simplest one to implement

### Positive Consequences

* Implementation can follow quickly
* Overall process is quite simple and can be trivially adapted to arbitrary field size

### Negative Consequences

* Even if simple, it is still not off-the-shelf approach

## Validation

Wallet spec receives test vectors, which are validated against at least 2 implementations (assuming one of them being the canonical one in Rust).

_Idea: should the other implementation be committed to arch repo and covered with CI? Should it land in wallet/ledger repo?_

## More info

Simplified code of the selected approach:
```ts
function toScalar(bytes: Buffer): BigInt {
    return BigInt(`0x${bytes.toString('hex')}`);
}
function sampleBytes(bytes: number, domainSeparator: string, seed: Buffer): Buffer {
    const rounds = Math.ceil(bytes/32);
    const result = Buffer.alloc(bytes);
    for (const i = 0; i < rounds; i++) {
        const segment = sha256(domainSeparator, sha256(i, seed));
        segment.copy(result, i * 32); // last segment gets truncated if overflows
    }
    return result;
}
function deriveAKey(seed: Buffer): BigInt {
    const theField = {
        bytes: 251,
        prime: 21888242871839275222246405745257275088614511777268538073601725287587578984328n
    }
    // Generating 16 bytes more is important to get a better distribution of keys
    const sampledBytes = sampleBytes(theField.bytes + 16, "midnight:some_key", seed);
    return toScalar(sampledBytes) % theField.prime;
}
```
