@startuml
actor User as user
box "Client (Javascript)" #eef
        control "dApp" as dapp
        entity "Lares\nClient\nLib" as lares
        entity "Transition\nFunction" as Gamma
        entity "Public\nOracle" as O_s
        entity "Private\nOracle" as O_r
        database "Public\nState" as s
        database "Private\nState" as r
        database "Private\nTranscript" as ptrans
        entity "Client\nEvent\nHandler" as eventHandler
end box
box "Proof Server" #a11
        participant ZKlib as zklib
end box
box "Wallet" 
        control wallet
        database "User\nTX's" as usertx
        database "User\nFilters" as filters
end box
boundary Network as network
box "Node" #afa
        control Consensus as consensus
        entity DustLedger as dust
        database MerkleTree
        database Nullifiers
        entity LaresLedger as contracts
        database Accounts as accounts
end box

group "Sync Current State"
        rnote over eventHandler
                Perform a sync for each dApp in the call graph,
                either eagerly (using graph analysis) or on
                demand as we encounter a call to any new dApp.
        endrnote
        user -> eventHandler: sync
        eventHandler -> wallet : poll tx's > last_seen
        rnote over eventHandler
                The backend and client both remember the last_seen
                block rank.  The wallet responds with the current
                public state σ and the sequence of all //intersting//
                transactions since last_seen.

                The wallet backend (and/or node) compute and propagate
                the contract public state, indexed by TX rank.  They
                can do this however they like: perhaps the node sends
                full state to the Backend, perhaps incremental updates,
                or perhaps transactions.
        endrnote
        wallet -> eventHandler : ⟨σ, {tx, ...}⟩ 
        eventHandler -> s : set [id=σ]\n//where id is the dApp id//
        eventHandler -> r : fetch(id)\n//where id is the dApp id//
        return ρ_0
        hnote over eventHandler: r = ρ
        loop for each tx, in consensus order
                alt one of my tx's
                        alt find/apply private transcript
                                eventHandler -> ptrans : fetch(txid)
                                return τ_txid
                                eventHandler -> O_r : applyTranscript(r,τ_txid)
                                return Ok (ρ', {e, ...})
                                eventHandler -> r : set [id=ρ']
                                eventHandler -> user : semantic events {e, ...}
                        else on any exception
                                hnote over eventHandler #f33: fatal error
                        end
                else another tx of interest
                        alt find/apply private transcript
                                eventHandler -> O_r : handleEvent(r,τ_txid)
                                return Ok (ρ', {e, ...})
                                eventHandler -> r : set [id=ρ']
                                eventHandler -> user : semantic events {e, ...}
                        else on any exception
                                hnote over eventHandler #f33: fatal error
                        end
                end
        end
end

group Call a semantic function
        user -> dapp : call(fun, [arg, ...] ∣ α, γ)
        rnote over dapp
                α is the //transaction accumulator//,
                initially ∅, used to batch multiple
                tx's across one or more dApps into
                an atomic multi-transaction
        endrnote
        rnote over dapp
                γ is the //gas accumulator//,
                initially 0, that tracks estimated
                gas costs across one or more dApps.
        endrnote
        group Fetch current state
                dapp -> s : fetch(id)
                return σ
                dapp -> r : fetch(id)
                return ρ
                rnote over dapp: var s = σ\nvar r = ρ
        end
        loop one call may generate multiple tx's
                alt Call a transition function
                        group call the transition function
                                dapp -> lares: call(f, [x, ...])
                                lares -> Gamma: call(f, [x, ...])
                                return Ok(v, σ', ρ', trid, witness, pub_trans, priv_trans, gas)
                                rnote over lares
                                        s := σ'
                                        r := ρ'
                                endrnote
                                lares -> zklib : prove(circuit_f, witness)
                                zklib -> lares: Ok(π)
                                lares -> ptrans: set [trid = priv_trans]
                                return Ok
                                rnote over lares
                                        α ⇽ α ∪ {⟨trid, π, pub_trans, gas⟩}
                                        γ ⇽ γ + gas 
                                endrnote
                                lares -> dapp: Ok(v ∣ α, γ)
                        end
                else Call another dApp
                        lares -> lares : call(other, [y, ...] | α, γ)
                        return Ok(v ∣ α, γ)
                        lares -> dapp: Ok(v ∣ α, γ)
                end
        end
end



group "Prepare Transaction"
        dapp -> wallet : prepare(multicall, α, γ)
        return Ok(proto_tx,cost,coins)
end

group "Verify Spend"
        dapp -> user : spend (cost,coins,id)?
        return Ok (id,sigs)
end

group "Publish Transaction"
        dapp -> wallet : submit(proto_tx,txid,sigs)
        wallet -> wallet : finish_tx(proto_tx,txid,sigs)
        return tx
        wallet -> usertx : originated(txid)
        wallet -> network : publish(tx)
        dapp -> user : pending (txid) //and other info?//
end

group "Consensus"
        network -> consensus : block(...,tx,...)
        consensus -> dust : verify coins
        dust -> MerkleTree : verify root & path
        return Ok
        dust -> Nullifiers : verify absence
        return Ok
        dust -> consensus : Ok
        group "Lares Ledger"
                consensus -> contracts : verify multitx
                loop for tx in multitx
                        contracts -> accounts : lookup tx.contract_id
                        return (code,circuits,σ)
                        contracts -> zklib : verify(circuit, tx.proof)
                        alt proof is verified
                                zklib -> contracts: Ok
                                alt apply public transcript
                                        rnote over contracts
                                                var O_σ = make_oracle(code, σ)
                                        endrnote
                                        loop (f, (x, ...), retval, gas) in tx.pub_transcipt
                                                rnote over contracts
                                                        Send //O_σ// message //f// with args
                                                        (//x//, ...).  Fail if the function
                                                        fails, if it runs out of gas, or if
                                                        its return value differs from //retval//
                                                endrnote
                                        end
                                        rnote over contracts
                                                If we got here, the transcript applied
                                                successfully
                                        endrnote
                                        contracts -> accounts : update_state(tx.contract_id, O_σ.state)
                                        return Ok
                                else on any failure
                                        hnote over contracts: maybe don't collect gas fees for the continuation?
                                        contracts -> consensus : Failure(details ...)
                                end
                        else proof fails
                                hnote over contracts: maybe don't collect gas fees for the continuation?
                                contracts -> consensus : Failure(details ...)
                        end
                end
                rnote over contracts
                        If we got here, all tx's in the multitx
                        were successfully verified
                endrnote
                contracts -> consensus : Ok
        end
end

group "Propagation"
        consensus -> wallet : block(...,[id=Ok],...)
        wallet -> usertx : originated id?
        return yes
end


@enduml
